### 模块和包
	常用 sys、OS 、 traceback 三个模块
	模块化编程
		模块： Modules， 模块就是Python程序，
			代码的可重复性体现在，编写好模块后，需用到该模块中的某个功能(由变量、函数、类实现)，无需重复性工作，直接导入该模块即可使用该功能
		封装特性的结构：
			1. 容器： 例 列表、元组、字符串、字典等，都是对数据的封装
			2. 函数： 对Python代码的封装
			3. 类： 对方法和属性的封装，对函数和数据的封装
		语法格式：
			模块名.函数
				
	导入模块： import 
		1. import 模块名1 [as 别名] , 模块名2 [as 别名2],... : 
			导入指定模块中的所有成员(变量、函数、类等)。 当使用模块中的成员时，需要该模块名(或别名)作为前缀
		2. from 模块名 import 成员名1 [as 别名1], 成员名2 [as 别名2] ,... :
			只会导入模块中指定的成员，非全部成员，使用该成员时，无需任何前缀，直接使用成员名或别名
			第二种from 模块名 import * ： 可导入指定模块中的所有成员
	
	import 模块名 as 别名
		1. 导入整个模块： import sys
		2. 导入整个模块，指定别名： import sys as s
		3. 导入多个模块： import sys，os
		4. 导入多个模块，同时指定别名： import sys as s, os as o
	
	from 模块名 import 成员名 as 别名
		1. 导入模块的成员 ： from sys import argv
		2. 导入模块成员，指定别名 ： from sys import argv as v
		3. 导入模块成员，一次导入多个成员 ： from sys import argv ， winver
		4. 导入多个模块，指定别名 ： from sys import argv as v， winver as w
		
		不推荐使用 from import 导入模块所有成员

	自定义模块
		模块文件的文件名是它的模块名，如 xxx.py 的模块名就是 xxx
	自定义模块编写测试代码
		如直接运行模块文件，程序会执行该模块的函数，如其他程序导入该模块，不应该执行该模块的函数
		要实现这个效果，需借助 python 内置的 __name__ 变量，当直接运行模块时， name 变量的值为 __main__; 而将模块被导入其他程序并运行该程序，处于模块中 __name__ 变量的值就编程类模块名。 如希望函数只有在直接运行模块文件时才执行，则可增加判断，即只有当 __name__ == '__main__' 时才调用函数
	
	__name__ == '__main__' :
		__name__ :内置的系统变量，用于标识所在模块的模块名，
		作用： 确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码，反之，如只是作为模块导入到其他程序文件中， 则此表达式不成立，若运行，不执行判断语句汇中的代码

	导入模块的三种方式
		当时用import 语句导入模块后，会按顺序查找指定的模块文件
			1. 当前目录，即当前执行的程序程序文件所在目录下查找
			2. 到Pythonpath 环境变量下的每个目录下查找
			3. 到python 默认的安装目录下查找
		自定义的模块：
			1. 向sys.path 中临时添加模块文件存储位置的完整路径
			2. 将模块放在sys.path 变量中已包含的模块加载路径中
			3. 设置系统环境变量
		导入模块方式一： 临时添加模块完整路径
		导入模块方式二： 将模块保存到指定位置
		导入模块方式三： 设置环境变量
			linux 设置环境变量：	
				vim ~/.bash_profile 
					PATHONPATH=.:/pythondir/python_module
					export PYTHONPATH
	
	导入模块的本质
		将xxx.py 中的全部代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块中定义的所有程序单元都相当于该module对象的成员
		导入同一模块多次，只执行一次
	
	__all__ 变量
		将变量的值设置为一个列表，只有该列表中的成员才会被暴露出来
			def xx():
				pass
			def xxx():
				pass
			__all__ = ['xx','xxx']
		意义：为模块定义开放的公公接口，只有 __all__变量列出的成员，
		如使用模块内__all__ 列表之外的成员，两种解决方法
			1. import 模块名  导入模块， 通过模块名前缀来调用模块内的成员
			2. from 模块名 import 成员 ，导入指定成员
	
	包： 存放多个模块的文件夹
		包：就是文件夹，必须存在名为 "__init__.py" 的文件
			每个包的目录下必须建立一个 __init__.py 的模块，可为空模块
			作用： 将目录当成包来处理
	
	创建包，导入包
		包的创建步骤：
			1. 创建文件夹，名称为该包的包名
			2. 文件夹内创建名为 __init__.py 的文件，
		包的导入：
			1. import 包名[.模块名[as 别名]]
				import xx.xxx
			2. from 包名 import 模块名 [as 别名]
				from xx import xxx
			3. from 包名.模块名 import 成员名 [as 别名]
				from xx.xxx import xxxx

	__init__.py
		导入包等同于导入包中的__init__.py文件，可在此文件中编写功能代码。 包作用是包含多个模块，因此此文件作用是导入该包内的其他模块
		
	查看模块(变量、函数、类)方法
		2种方式：
			1. dir()
				dir(xxx)
			2. __all__
				xxx.__all__
	
	__doc__属性：查看文档
		help(string.capwords)
		print(string.capwords.__doc__)
	
	__file__属性：查看模块的源文件路径
		import string		
		string.__file__
	
	第三方模块(库)下载和安装(通过pip命令)
		pip install | uninstall | list  模块名



